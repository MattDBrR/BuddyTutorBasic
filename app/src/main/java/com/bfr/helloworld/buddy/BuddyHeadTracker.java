package com.bfr.helloworld.buddy;

import android.os.Handler;
import android.os.Looper;
import android.os.RemoteException;
import com.bfr.buddy.usb.shared.IUsbCommadRsp;
import com.bfr.buddy.vision.shared.Tracking;
import com.bfr.buddysdk.BuddySDK;
import com.bfr.helloworld.utils.Logger;

/**
 * Gestionnaire du suivi de t√™te automatique de Buddy
 * Suit automatiquement les personnes d√©tect√©es par la vision
 */
public class BuddyHeadTracker {
    private static final String TAG = "BuddyHeadTracker";

    // Configuration du suivi
    private static final long TRACKING_REFRESH_INTERVAL = 100; // 100ms = 10 FPS
    private static final float HEAD_MOVEMENT_THRESHOLD = 0.10f; // Seuil de d√©clenchement (15% de l'√©cran)
    private static final float HEAD_SPEED = 40.0f; // Vitesse des mouvements
    private static final float HEAD_ANGLE_STEP = 10.0f; // Angle par √©tape
    private static final long MOVEMENT_COOLDOWN = 300; // D√©lai entre mouvements (ms)

    // √âtat du tracker
    private boolean isTrackingActive = false;
    private boolean areMotorsEnabled = false;
    private Thread trackingThread;
    private final Handler handler;
    private long lastMovementTime = 0;

    // Callback pour les √©v√©nements
    public interface HeadTrackerCallback {
        void onTrackingStarted();
        void onTrackingStopped();
        void onPersonDetected(float centerX, float centerY);
        void onPersonLost();
        void onHeadMovement(String direction, float angle);
        void onError(String error);
    }

    private HeadTrackerCallback callback;

    public BuddyHeadTracker() {
        this.handler = new Handler(Looper.getMainLooper());
        Logger.i(TAG, "BuddyHeadTracker initialis√©");
    }

    /**
     * D√©finit le callback pour les √©v√©nements
     */
    public void setCallback(HeadTrackerCallback callback) {
        this.callback = callback;
    }

    /**
     * D√©marre le suivi de t√™te
     */
    public void startTracking() {
        if (isTrackingActive) {
            Logger.w(TAG, "Suivi d√©j√† actif");
            return;
        }

        Logger.i(TAG, "üéØ D√©marrage du suivi de t√™te");

        // Activer les moteurs d'abord
        enableHeadMotors(() -> {
            // Une fois les moteurs activ√©s, d√©marrer le suivi
            startTrackingLoop();
        });
    }

    /**
     * Arr√™te le suivi de t√™te
     */
    public void stopTracking() {
        if (!isTrackingActive) {
            Logger.d(TAG, "Suivi d√©j√† arr√™t√©");
            return;
        }

        Logger.i(TAG, "üõë Arr√™t du suivi de t√™te");
        isTrackingActive = false;

        // Arr√™ter le thread
        if (trackingThread != null && trackingThread.isAlive()) {
            trackingThread.interrupt();
            try {
                trackingThread.join(2000); // Attendre maximum 2 secondes
                Logger.d(TAG, "Thread de suivi arr√™t√©");
            } catch (InterruptedException e) {
                Logger.w(TAG, "Interruption lors de l'arr√™t du thread");
                Thread.currentThread().interrupt();
            }
        }

        // Callback
        if (callback != null) {
            handler.post(() -> callback.onTrackingStopped());
        }
    }

    /**
     * Active les moteurs de t√™te
     */
    private void enableHeadMotors(Runnable onComplete) {
        Logger.d(TAG, "Activation des moteurs de t√™te...");

        try {
            // Activer le moteur "Yes" (haut/bas)
            BuddySDK.USB.enableYesMove(true, new IUsbCommadRsp.Stub() {
                @Override
                public void onSuccess(String success) throws RemoteException {
                    Logger.d(TAG, "‚úÖ Moteur YES activ√©");

                    // Activer le moteur "No" (gauche/droite)
                    try {
                        BuddySDK.USB.enableNoMove(true, new IUsbCommadRsp.Stub() {
                            @Override
                            public void onSuccess(String success) throws RemoteException {
                                Logger.d(TAG, "‚úÖ Moteur NO activ√©");
                                areMotorsEnabled = true;

                                // Callback et d√©marrage
                                if (onComplete != null) {
                                    onComplete.run();
                                }
                            }

                            @Override
                            public void onFailed(String error) throws RemoteException {
                                Logger.e(TAG, "‚ùå √âchec activation moteur NO: " + error);
                                notifyError("√âchec activation moteur NO: " + error);
                            }
                        });
                    } catch (Exception e) {
                        Logger.e(TAG, "Exception activation moteur NO", e);
                        notifyError("Exception moteur NO: " + e.getMessage());
                    }
                }

                @Override
                public void onFailed(String error) throws RemoteException {
                    Logger.e(TAG, "‚ùå √âchec activation moteur YES: " + error);
                    notifyError("√âchec activation moteur YES: " + error);
                }
            });
        } catch (Exception e) {
            Logger.e(TAG, "Exception activation moteurs", e);
            notifyError("Exception activation moteurs: " + e.getMessage());
        }
    }

    /**
     * D√©marre la boucle de suivi
     */
    private void startTrackingLoop() {
        if (!areMotorsEnabled) {
            Logger.e(TAG, "Impossible de d√©marrer - moteurs non activ√©s");
            notifyError("Moteurs non activ√©s");
            return;
        }

        Logger.i(TAG, "üéØ D√©marrage du tracking de vision...");

        try {
            // √âTAPE CRITIQUE : D√©marrer le tracking de vision d'abord
            BuddySDK.Vision.startTracking();
            Logger.d(TAG, "‚úÖ Vision tracking d√©marr√©");

            // D√©lai pour laisser le temps au tracking de s'initialiser
            Thread.sleep(500);

        } catch (Exception e) {
            Logger.e(TAG, "‚ùå √âchec d√©marrage vision tracking", e);
            notifyError("Impossible de d√©marrer le tracking de vision: " + e.getMessage());
            return;
        }

        isTrackingActive = true;
        lastMovementTime = 0;

        // Callback
        if (callback != null) {
            handler.post(() -> callback.onTrackingStarted());
        }

        trackingThread = new Thread(() -> {
            Logger.i(TAG, "üîÑ Thread de suivi d√©marr√©");

            while (isTrackingActive && !Thread.currentThread().isInterrupted()) {
                try {
                    // Obtenir les donn√©es de tracking
                    Tracking trackingData = BuddySDK.Vision.getTracking();

                    if (!trackingData.isTrackingSuccessfull()) {
                        // Personne perdue
                        handlePersonLost();
                        Thread.sleep(TRACKING_REFRESH_INTERVAL);
                        continue;
                    }

                    // Calculer la position du centre du visage
                    float centerX = (trackingData.getLeftPos() + trackingData.getRightPos()) / 2.0f;
                    float centerY = (trackingData.getTopPos() + trackingData.getBottomPos()) / 2.0f;

                    // Calculer les √©carts par rapport au centre de l'√©cran
                    float deltaX = centerX - 0.5f; // -0.5 √† 0.5
                    float deltaY = centerY - 0.5f; // -0.5 √† 0.5

                    Logger.d(TAG, String.format("Position: X=%.2f, Y=%.2f, ŒîX=%.2f, ŒîY=%.2f",
                            centerX, centerY, deltaX, deltaY));

                    // Notifier la d√©tection
                    if (callback != null) {
                        handler.post(() -> callback.onPersonDetected(centerX, centerY));
                    }

                    // V√©rifier et effectuer les mouvements
                    checkAndMoveHead(deltaX, deltaY);

                    // Attendre avant la prochaine it√©ration
                    Thread.sleep(TRACKING_REFRESH_INTERVAL);

                } catch (InterruptedException e) {
                    Logger.i(TAG, "Thread de suivi interrompu");
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    Logger.e(TAG, "Erreur dans la boucle de suivi", e);
                    notifyError("Erreur de suivi: " + e.getMessage());

                    try {
                        Thread.sleep(TRACKING_REFRESH_INTERVAL);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }

            Logger.i(TAG, "üèÅ Thread de suivi termin√©");
        });

        trackingThread.start();
    }

    /**
     * G√®re la perte de la personne
     */
    private void handlePersonLost() {
        if (callback != null) {
            handler.post(() -> callback.onPersonLost());
        }
    }

    /**
     * V√©rifie les seuils et effectue les mouvements appropri√©s
     */
    private void checkAndMoveHead(float deltaX, float deltaY) {
        long currentTime = System.currentTimeMillis();

        // V√©rifier le cooldown pour √©viter les mouvements trop fr√©quents
        if (currentTime - lastMovementTime < MOVEMENT_COOLDOWN) {
            return;
        }

        try {
            boolean hasMoved = false;

            // Mouvement horizontal (gauche/droite) - PRIORIT√â
            if (Math.abs(deltaX) > HEAD_MOVEMENT_THRESHOLD) {
                if (deltaX > 0) {
                    // Personne √† droite
                    Logger.d(TAG, "‚û°Ô∏è Mouvement t√™te DROITE");
                    moveHeadNo(HEAD_SPEED, HEAD_ANGLE_STEP);
                    notifyMovement("DROITE", HEAD_ANGLE_STEP);
                } else {
                    // Personne √† gauche
                    Logger.d(TAG, "‚¨ÖÔ∏è Mouvement t√™te GAUCHE");
                    moveHeadNo(HEAD_SPEED, -HEAD_ANGLE_STEP);
                    notifyMovement("GAUCHE", -HEAD_ANGLE_STEP);
                }
                hasMoved = true;
            }
            // Mouvement vertical seulement si pas de mouvement horizontal
            else if (Math.abs(deltaY) > HEAD_MOVEMENT_THRESHOLD) {
                if (deltaY > 0) {
                    // Personne en bas
                    Logger.d(TAG, "‚¨áÔ∏è Mouvement t√™te BAS");
                    moveHeadYes(HEAD_SPEED, -HEAD_ANGLE_STEP);
                    notifyMovement("BAS", -HEAD_ANGLE_STEP);
                } else {
                    // Personne en haut
                    Logger.d(TAG, "‚¨ÜÔ∏è Mouvement t√™te HAUT");
                    moveHeadYes(HEAD_SPEED, HEAD_ANGLE_STEP);
                    notifyMovement("HAUT", HEAD_ANGLE_STEP);
                }
                hasMoved = true;
            }

            // Mettre √† jour le timestamp si mouvement effectu√©
            if (hasMoved) {
                lastMovementTime = currentTime;
            }

        } catch (Exception e) {
            Logger.e(TAG, "Erreur lors du mouvement de t√™te", e);
            notifyError("Erreur mouvement: " + e.getMessage());
        }
    }

    /**
     * Effectue un mouvement horizontal (No movement)
     */
    private void moveHeadNo(float speed, float angle) {
        try {
            BuddySDK.USB.buddySayNo(speed, angle, new IUsbCommadRsp.Stub() {
                @Override
                public void onSuccess(String success) throws RemoteException {
                    if ("NO_MOVE_FINISHED".equals(success)) {
                        Logger.d(TAG, "Mouvement horizontal termin√©");
                    }
                }

                @Override
                public void onFailed(String error) throws RemoteException {
                    Logger.e(TAG, "√âchec mouvement horizontal: " + error);
                }
            });
        } catch (Exception e) {
            Logger.e(TAG, "Exception mouvement horizontal", e);
        }
    }

    /**
     * Effectue un mouvement vertical (Yes movement)
     */
    private void moveHeadYes(float speed, float angle) {
        try {
            BuddySDK.USB.buddySayYes(speed, angle, new IUsbCommadRsp.Stub() {
                @Override
                public void onSuccess(String success) throws RemoteException {
                    if ("YES_MOVE_FINISHED".equals(success)) {
                        Logger.d(TAG, "Mouvement vertical termin√©");
                    }
                }

                @Override
                public void onFailed(String error) throws RemoteException {
                    Logger.e(TAG, "√âchec mouvement vertical: " + error);
                }
            });
        } catch (Exception e) {
            Logger.e(TAG, "Exception mouvement vertical", e);
        }
    }

    /**
     * Centre la t√™te (position neutre)
     */
    public void centerHead() {
        if (!areMotorsEnabled) {
            Logger.w(TAG, "Impossible de centrer - moteurs non activ√©s");
            return;
        }

        Logger.i(TAG, "üéØ Centrage de la t√™te");

        try {
            // Retour position neutre horizontale
            BuddySDK.USB.buddySayNo(HEAD_SPEED, 0, new IUsbCommadRsp.Stub() {
                @Override
                public void onSuccess(String success) throws RemoteException {
                    // Retour position neutre verticale
                    try {
                        BuddySDK.USB.buddySayYes(HEAD_SPEED, 0, new IUsbCommadRsp.Stub() {
                            @Override
                            public void onSuccess(String success) throws RemoteException {
                                Logger.i(TAG, "‚úÖ T√™te centr√©e");
                            }

                            @Override
                            public void onFailed(String error) throws RemoteException {
                                Logger.e(TAG, "√âchec centrage vertical: " + error);
                            }
                        });
                    } catch (Exception e) {
                        Logger.e(TAG, "Exception centrage vertical", e);
                    }
                }

                @Override
                public void onFailed(String error) throws RemoteException {
                    Logger.e(TAG, "√âchec centrage horizontal: " + error);
                }
            });
        } catch (Exception e) {
            Logger.e(TAG, "Exception centrage t√™te", e);
        }
    }

    /**
     * UTILITAIRES ET GETTERS
     */
    public boolean isTrackingActive() {
        return isTrackingActive;
    }

    public boolean areMotorsEnabled() {
        return areMotorsEnabled;
    }

    /**
     * Configure les param√®tres de suivi
     */
    public void setTrackingParameters(float threshold, float speed, float angleStep) {
        // Note: Ces param√®tres pourraient √™tre rendus configurables
        // Pour l'instant, ils sont constants
        Logger.i(TAG, "Configuration: seuil=" + threshold + ", vitesse=" + speed + ", angle=" + angleStep);
    }

    /**
     * CALLBACKS HELPERS
     */
    private void notifyError(String error) {
        if (callback != null) {
            handler.post(() -> callback.onError(error));
        }
    }

    private void notifyMovement(String direction, float angle) {
        if (callback != null) {
            handler.post(() -> callback.onHeadMovement(direction, angle));
        }
    }

    /**
     * Nettoyage des ressources
     */
    public void cleanup() {
        Logger.i(TAG, "üßπ Nettoyage BuddyHeadTracker");
        stopTracking();

        // Centrer la t√™te avant arr√™t
        if (areMotorsEnabled) {
            centerHead();
        }
    }
}
